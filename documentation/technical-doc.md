
# Architectural solutions

**1) Абстрактный класс `Unit`**
У вражеских юнитов и юнита главного персонажа, которым управляет игрок, есть несколько общих полей, например, позиция и геометрическая форма, и методов, например, функция `update(time)` обновляющая игровую логику юнита. Поэтому удобным решением будет создание абстрактного класса `Unit`, от которого будут унаследованы классы `HeroUnit`, класс главного юнита, и `EnemyUnit`, класс вражеских юнитов. 

**2) Паттерн `Abstract Factory` в реализации классов вражеских юнитов**
В начале игры мы узнаем тип вражеских юнитов, т.е. геометрическую форму, но все три цвета: красный, зеленый, синий - будут использоваться все зависимости от изначального выбора типа. Поэтому удобно использовать паттерн `Abstract Factory`. Создадим абстрактный класс `EnemyUnit`, от которого будут наследоваться три класса: `WeakEnemyUnit`, `StrongEnemyUnit`, `MightyEnemyUnit` - красный, синий и зеленый вражеский юнит соответственно. 

Также создадим абстрактный класс - абстрактную фабрику `UnitsFactory`, у которой есть методы, позволяющие создать вражеского юнита конкретного цвета. От этого класса будут наследоваться два класса: `СircleUnitsFactory`, `SquareUnitsFactory` - две фабрики, по одной на каждую геометрическую форму вражеского юнита, позволяющие создавать вражеских юнитов разных цветов, но одной геометрической формы.

**3) Класс `HeroUnit`**
Удобно вынести всю игровую логику и информацию о юните главного персонажа в отдельный класс `HeroUnit`, т.е. у него могут быть дополнительные поля, например, свой массив пуль, время перезарядки супер атаки, контроллер, и методы, например, вспомогательные функции обработки передвижения и атаки со своей сложной логикой. Также такое решение дает больше свободы в добавлении фич в дальнейшем.

**4) Паттерн `Singleton` в реализации классов `СircleUnitsFactory`, `SquareUnitsFactory`**
Т.к. нам нужно только по одной сущности каждой из фабрик, которые будут использоваться в разных частях программы, логично использовать паттерн `Singleton`.

**5) Классы `Window`, `Controller` и `KeyboardController`, `Game`** 
* Класс `Window` будет содержать методы позволяющие работать с графической библиотекой. Все обращения к методам библиотеки сокрыты именно здесь.

* Класс `KeyboardController` унаследован от абстрактного класса `Controller`. Вся логика взаимодействие с контроллером описана именно здесь. Абстрактный класс позволяет нам использовать различные контроллеры для игры с единым внутренним интерфейсом. Также такая реализация упрощает добавление поддержки новых контроллеров для игры. Конкретно класс `KeyboardController` реализует управление игровой логикой с помощью клавиатуры.

* Класс `Game` внутри себя хранит все объекты, содержащиеся в игре, например, фабрику для создания вражеских юнитов, массив вражеских юнитов, массив их пуль, главного персонажа (объект класса `UnitHero`).

В явном виде паттерн `Singleton` здесь не используется, т.к. и так будет создано только по одной сущности классов `Window` и `Game` в функции `main`, и `Controller` внутри объекта класса `UnitHero`. 

**5) Класc `TestingModule`** 

Для тестирования приватных методов описанных выше классов используется вспомогательный класс `TestingModule`. Он является другом классов, к которым происходит обращение при тестировании. Таким образом, такое решение помогает минимально изменять исходный код. Также реализация класса `TestingModule` и других модулей, используемых для тестирования, отделена от исходного кода проекта.

# Implementation solutions

* В качестве графического модуля используется библиотека `SFML`.

* Для тестирования используется библиотека `Boost`.

* В файле `main.cpp` в функции `main` находится главный цикл игры, таймер, а также вызов методов для обновления игровой логики и графического интерфейса.

* Паттерн `Singleton` реализован по примеру Скотта Майерса (Scott Meyers).

* В проекте используются умные указатели из стандартной библиотеки.

* При сборки проекта для тестирования указывается definition `-DTESTING_MODE `. Без него классы проекта не будут друзьями класса `TestingModule`.

